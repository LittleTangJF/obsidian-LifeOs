### 传统问题**传统 React 的痛点​**

- ​**​同步阻塞​**​：旧版 React 使用递归遍历组件树（Stack Reconciler），一旦开始渲染会占用主线程直至完成，导致复杂组件树渲染时界面卡顿
- **无法中断​**​：渲染过程不可中断，无法响应高优先级任务（如用户点击）
- **单一优先级​**​：所有更新按相同顺序处理，无法优化关键任务（如动画）的响应速度

### 引出fiber

- **增量渲染​**​：将渲染任务拆分为可中断的小单元（Fiber 节点），分批次执行
- **优先级调度​**​：区分任务紧急程度（如用户输入 > 动画 > 数据加载），动态调整执行顺序
- **并发模式支持​**​：允许同时处理多个 UI 版本，实现平滑过渡

### 底层原理

- **节点的数据结构​** - 链表结构构建组件树，每个组件对应一个fiber节点
	-  ​**​Lanes 模型（车道系统）​**二进制位掩码（bitmask）表示任务优先级
	- type类型
	- effectTag
	- stateMode
- **双缓冲机制​**- 维护两棵 Fiber 树
	- ​**​Current Tree​**​：当前显示的 UI 树
	- **WorkInProgress Tree​**​：正在构建的新树
	- 更新完成后，两棵树交换角色，确保渲染无闪烁
- **任务调度与时间切片**​**
	- 时间切片**将长任务拆分为多个帧执行，避免阻塞动画和用户交互
	- 通过 `performUnitOfWork`逐个处理 Fiber 节点，每次执行后检查主线程是否空闲（`shouldYield`），允许中断低优先级任务
		- deadline.timeRemaining() > 0
- #### **两阶段渲染流程**
	- **调和阶段（Reconcile Phase）**​**
		- 可中断：遍历 Fiber 树，标记差异（Diffing）并收集副作用。​
	- ​**​提交阶段（Commit Phase）​**​：
		- 不可中断：批量执行 DOM 操作（如插入、删除），确保 UI 一致性。

### Diff算法
**最长递增子序列（LIS）​**​：通过 LIS 算法确定无需移动的节点顺序，仅处理位置变化的节点
#### 1. ​**​第一遍遍历：处理可复用节点​**
- （`key`和 `type`相同）：复用 Fiber 节点，更新属性。
- **部分匹配​**​（`key`相同但 `type`不同）：标记为删除旧节点，创建新节点
- **不匹配​**​：终止遍历，进入第二遍遍历
#### 2. ​**​第二遍遍历：处理剩余节点**
- ​**​剩余旧节点入 Map​**​：将未匹配的旧节点按 `key`存入 Map。
- **遍历新节点​**​：查找 Map 中可复用的节点
	- **存在匹配​**​：移动节点到正确位置，标记为更新。
	- **无匹配​**​：标记为新增节点。
- ​**​清理残留旧节点​**​：Map 中未匹配的节点标记为删除